\documentclass[14pt,a4paper,report]{ncc}
\usepackage[a4paper, mag=1000, left=2.5cm, right=1cm, top=2cm, bottom=2cm, headsep=0.7cm, footskip=1cm]{geometry}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks]{hyperref}
\usepackage{listings} 
\usepackage{caption}
\everymath{\displaystyle}

\begin{document}

\textbf{Задача 1}

Динамика будет следующей:\\
В верхнем индексе у меня находится сам индекс, а не степень числа, для удобства записи.\\
Ребра графа "--- множество $E$, $n = |V|$\\
Хотим посчитать для каждой пары (множество $S$, вершина в нём $z$) такую функцию $d_S^z$ "--- путь минимального веса из вершины с наименьшим номером в $S$ до $z$.\\
По этой функции легко посчитать ответ на задачу, нужно для каждого множества перебрать соседей минимальной вершины и улучшить ответ циклом, который проходит через соответствующее ребро.\\
Очевидно мы найдем оптимальный цикл, потому что он проходит через одно из рёбер первой вершины, а мы перебрали их все.\\

\textit{Начальные состояния и пересчет:}\\
Пусть $x$ "--- минимальный элемент в множестве $S$, $z$ "--- последняя посещенная в $S$ вершина.\\
\begin{enumerate}
    \item {
        $\forall x \in V: d_{\{x\}}^{x} = 0$
    }
    \item {
        $T = \{y \text{ | } y \in S$, $y > x$, $ y \neq z$, $(y, z) \in E\}$\\
        $d_{S}^{z} = \min_{y \in T}(d_{S \setminus \{z\}}^{y} + w(y, z))$\\
    }
\end{enumerate}

\textit{Порядок обхода:}\\
Что-бы упростить доказательство воспользуемся ленивой динамикой.\\
Допустим, мы хотим узнать $d_S^z$. Если мы его уже когда-то считали, то просто вернём ранее посчитанное значение, потому что с прошлого раза оно не могло измениться.\\
Иначе честно посчитаем его, но когда будем обращаться к предыдущим состояниям, то будем аналогично нам спрашивать, посчитали вас ранее или нет.\\
Получается рекурсивная функция, которая (немного философии) по структуре динамики сама построит правильный порядок обхода (если граф ациклический).\\

\textit{Время работы:}\\
Всего возможных подмножеств "--- $\mathcal{O}(2^{n})$, а возможных последних элементов "--- $\mathcal{O}(n)$.\\
Тогда всего $\mathcal{O}(n \cdot 2^n)$.\\
Каждое состояние пересчитывается за $\mathcal{O}(n) \Rightarrow \\ \Rightarrow$ Мы можем посчитать все состояния за время порядка $\mathcal{O}(n^2 \cdot 2^n)$\\
Стоит сказать пару слов об ленивом вычислении.\\
Мы не теряем в скорости, потому что на вычисление каждого состояния всё так же тратим $\mathcal{O}(n)$ времени.\\


\textbf{Задача 2} \textit{(бояны возвращаются)}\\

Нам нужно посчитать $LCS$ (Longest Common Subsequence) двух строк.\\
Если длина одной из строк равна нулю, то $LCS$ равна нулю и ничего восстанавливать не нужно.\\
Если длина одной из строк равна единице, то нужно просто проверить, а не содержится ли этот символ в другой строке? Если да, то ответом будет этот символ. Если нет, то ответ "--- пустая строка.\\
Ну, частные случаи можно разбирать долго.\\

Вот есть две строки $S, T: |S| \geq |T|$. Пусть $n = |S|, m = |T|$\\
Разобьем строку $S$ на две примерно равных.
$s_1 = S_0 S_1 \ldots S_{\frac{n}{2}}$, $s_2 = S_{\frac{n}{2}+1} S_{\frac{n}{2}+2} \ldots S_{n-1}$\\

Чуть заглянув в завтрашний день и посмотрим где находится $LCS$ во второй строке. Какой-то префикс её будет "мэтчиться" с $s_1$, а соответствующий суффикс с $s_2$ и никак иначе. Ну, в силу того что это всё-таки подпоследовательность и её можно разбить на первую половину и вторую.\\

Теперь у нас есть направление в котором стоит думать.\\ Посчитаем (обычной динамикой с лекции) $LCS$ от $s_1$ и всех префиксов $T$.\\
Теперь хотим посчитать $LCS$ от $s_2$ и всех суффиксов $T$. Это чуть менее тривиально. Заметим что это тоже самое, что посчитать $LCS^r$ от $s_2^r$ и $T^r$. Сохраним длины $LCS$ в массивы $L^p$ и $L^s$ (первый соответствует префиксу длины $p$, а второй "--- суффиксу длины $s$).\\
Теперь переберём точку в которой происходит "разделение" $LCS$ на две части.\\
$i: L^p_{i} + L^s_{m - i} \rightarrow max$\\
Вот в этой точке оптимальнее всего разбить подпоследовательность на две.\\
Вызовемся рекурсивно от $(s_1, \text{$i$-й префикс $T$})$ и $(s_2, \text{$(m - i)$-й суффикс $T$})$\\
Ответом для наших строк будет конкатенация ответов рекурсивных вызовов.\\
База рекурсии есть "--- пустая строка, или строка из одного символа.\\

\textit{Время работы}\\
На каждом слое рекурсии у нас сумма длин вторых строк постоянна и равна $m$.\\
Глубина рекурсии будет $\log_2{n}$, потому что делим пополам каждый раз.\\
Тогда на глубине $h$ мы потратим $\frac{n}{2^h} \cdot \sum{m_i} = \frac{n \cdot m}{2^h}$\\
Всего получается: $\sum_{h=0}^{\infty}\frac{n \cdot m}{2^h} = \mathcal{O}(n \cdot m)$

\textbf{Задача 4} (я извиняюсь за копипасту, но это нужно)\\

Динамика будет следующей:\\
В верхнем индексе у меня находится сам индекс, а не степень числа, для удобства записи.\\
Ребра графа "--- множество $E$, вершины "--- $V$.\\
Хотим посчитать для каждой пары (множество $S$, вершина в нём $z$) такую функцию $d_S^z$ "--- количество простых путей из вершины с наименьшим номером в $S$ до $z$.\\

Пусть $\forall S$, $\operatorname{first}(S)$ "--- минимальный элемент в множестве (первый).\\
Тогда для подсчета ответа нужно для каждого подмножества размера хотя-бы $3$, найти минимальную вершину и посмотреть на её соседей, лежащих в множестве.\\
Ответ $\sum_{S \subseteq V}{\sum_{(v \text{,} \operatorname{first}(s)) \in E}{d_{S}^v}}$\\
Для простоты будем считать что $\forall S, v: v \notin S, d_{S}^{v}=0$\\

\textit{Начальные состояния и пересчет:}\\
Пусть $x$ "--- минимальный элемент в множестве $S$, $z$ "--- последняя посещенная в $S$ вершина.\\
\begin{enumerate}
    \item {
        $\forall x \in V: d_{\{x\}}^{x} = 1$\\
        Логично, один способ добраться из $x$ в $x$
    }
    \item {
        $T = \{y \text{ | } y \in S$, $y > x$, $ y \neq z$, $(y, z) \in E\}$\\
        $d_{S}^{z} = \sum_{y \in T}{d_{S \setminus \{z\}}^{y}}$\\
        Мы продлеваем каждый путь из меньшего подмножества.
    }
\end{enumerate}

\textit{Порядок обхода:}\\
Абсолютно как в задаче $1$, ленивая динамика.

\textit{Время работы:}\\
Ничего не поменялось относительно задачи $1$, время работы $\mathcal{O}(2^n \cdot n^2)$.

\end{document}